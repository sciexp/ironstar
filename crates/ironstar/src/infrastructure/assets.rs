//! Asset manifest for resolving content-hashed filenames.
//!
//! Rolldown generates a manifest.json mapping logical entry names to their
//! content-hashed output filenames. This module parses that manifest and
//! provides lookup for templates to reference assets with cache-busting URLs.

use serde::Deserialize;
use std::collections::HashMap;

/// Asset manifest mapping entry names to hashed filenames.
///
/// Generated by rollup-plugin-output-manifest during the frontend build.
/// The manifest format is a flat object: `{"bundle.js": "bundle-a1b2c3.js"}`.
#[derive(Debug, Clone, Deserialize)]
pub struct AssetManifest(HashMap<String, String>);

impl AssetManifest {
    /// Load manifest from the embedded static/dist/manifest.json.
    ///
    /// In production, this uses `include_str!` to embed the manifest at compile time.
    /// Returns an empty manifest if the file doesn't exist (development without build).
    pub fn load() -> Self {
        // For now, return empty manifest - ny3.13 will add rust-embed integration
        // and conditional loading based on build mode
        Self(HashMap::new())
    }

    /// Parse manifest from JSON string.
    ///
    /// # Errors
    /// Returns error if JSON is malformed.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        serde_json::from_str(json)
    }

    /// Resolve a logical entry name to its hashed filename.
    ///
    /// Returns the hashed filename if found, or the original name as fallback.
    /// This fallback behavior allows development mode to work without a manifest.
    ///
    /// # Example
    /// ```ignore
    /// let manifest = AssetManifest::from_json(r#"{"bundle.js": "bundle-abc123.js"}"#)?;
    /// assert_eq!(manifest.resolve("bundle.js"), "bundle-abc123.js");
    /// assert_eq!(manifest.resolve("unknown.js"), "unknown.js"); // fallback
    /// ```
    pub fn resolve<'a>(&'a self, entry: &'a str) -> &'a str {
        self.0.get(entry).map(|s| s.as_str()).unwrap_or(entry)
    }

    /// Check if the manifest contains an entry.
    pub fn contains(&self, entry: &str) -> bool {
        self.0.contains_key(entry)
    }

    /// Returns true if manifest is empty (no entries loaded).
    pub fn is_empty(&self) -> bool {
        self.0.is_empty()
    }
}

impl Default for AssetManifest {
    fn default() -> Self {
        Self(HashMap::new())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_manifest() {
        let json = r#"{"bundle.js": "bundle-abc123.js", "bundle.css": "bundle-def456.css"}"#;
        let manifest = AssetManifest::from_json(json).unwrap();

        assert_eq!(manifest.resolve("bundle.js"), "bundle-abc123.js");
        assert_eq!(manifest.resolve("bundle.css"), "bundle-def456.css");
    }

    #[test]
    fn test_fallback_on_missing() {
        let manifest = AssetManifest::default();
        assert_eq!(manifest.resolve("unknown.js"), "unknown.js");
    }

    #[test]
    fn test_empty_manifest() {
        let manifest = AssetManifest::default();
        assert!(manifest.is_empty());
        assert!(!manifest.contains("bundle.js"));
    }
}
