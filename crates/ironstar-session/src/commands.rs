//! Commands for the Session aggregate.
//!
//! Commands represent requests to change aggregate state. They are:
//!
//! - **Imperative**: Named for what should happen (Create, Refresh, Invalidate)
//! - **Validatable**: The aggregate may accept or reject them
//! - **Carry boundary-injected values**: All timestamps, IDs, and metadata
//!   are injected at the boundary layer, not generated in the domain
//!
//! # Command vs Event
//!
//! | Aspect | Command | Event |
//! |--------|---------|-------|
//! | Tense | Imperative (Create) | Past (Created) |
//! | Outcome | May fail | Already happened |
//! | Data | Boundary-injected values | Domain facts |
//! | Source | External (OAuth callback, timer) | Internal (aggregate) |
//!
//! # Boundary injection pattern
//!
//! Commands carry all values that would require side effects to generate:
//! - `session_id`: Generated by boundary layer
//! - `user_id`: Resolved from OAuth identity at boundary
//! - `created_at`, `refreshed_at`, `invalidated_at`: Clock reads at boundary
//! - `expires_at`: Computed from created_at + TTL at boundary
//! - `metadata`: Extracted from HTTP request at boundary

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use ts_rs::TS;

use crate::values::{OAuthProvider, SessionId, SessionMetadata, UserId};
use ironstar_core::{DeciderType, Identifier};

/// Commands that can be sent to the Session aggregate.
///
/// Each command represents an authentication-related intention. The aggregate
/// validates the command against its current state and either:
///
/// - Emits events (success)
/// - Returns an error (validation failure)
///
/// Commands are constructed at the boundary layer after OAuth callbacks
/// or session management operations.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, TS)]
#[serde(tag = "type")]
#[ts(export, export_to = "commands/")]
pub enum SessionCommand {
    /// Create a new session after successful OAuth authentication.
    ///
    /// All fields are injected by the boundary layer:
    /// - `session_id`: Fresh UUID generated after OAuth callback
    /// - `user_id`: Resolved from OAuth provider identity
    /// - `provider`: Which OAuth provider authenticated the user
    /// - `created_at`: Current timestamp
    /// - `expires_at`: created_at + session TTL
    /// - `metadata`: HTTP request context for audit trail
    Create {
        /// Fresh session identifier.
        session_id: SessionId,
        /// Canonical user identifier.
        user_id: UserId,
        /// OAuth provider that authenticated this session.
        provider: OAuthProvider,
        /// When the session was created.
        created_at: DateTime<Utc>,
        /// When the session expires.
        expires_at: DateTime<Utc>,
        /// Audit trail metadata.
        metadata: SessionMetadata,
    },

    /// Refresh an active session to extend its TTL.
    ///
    /// Called periodically while user is active to prevent expiration.
    Refresh {
        /// Session to refresh.
        session_id: SessionId,
        /// When the refresh occurred.
        refreshed_at: DateTime<Utc>,
        /// New expiration timestamp.
        new_expires_at: DateTime<Utc>,
    },

    /// Invalidate an active session (explicit logout).
    ///
    /// Called when user logs out or admin terminates session.
    Invalidate {
        /// Session to invalidate.
        session_id: SessionId,
        /// When invalidation occurred.
        invalidated_at: DateTime<Utc>,
    },
}

impl SessionCommand {
    /// Extract the target aggregate ID from the command.
    ///
    /// Used by command handlers to load the correct aggregate.
    #[must_use]
    pub fn aggregate_id(&self) -> SessionId {
        match self {
            Self::Create { session_id, .. }
            | Self::Refresh { session_id, .. }
            | Self::Invalidate { session_id, .. } => *session_id,
        }
    }

    /// Get the command type name for logging and metrics.
    #[must_use]
    pub fn command_type(&self) -> &'static str {
        match self {
            Self::Create { .. } => "Create",
            Self::Refresh { .. } => "Refresh",
            Self::Invalidate { .. } => "Invalidate",
        }
    }
}

impl Identifier for SessionCommand {
    fn identifier(&self) -> String {
        self.aggregate_id().to_string()
    }
}

impl DeciderType for SessionCommand {
    fn decider_type(&self) -> String {
        "Session".to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn sample_time() -> DateTime<Utc> {
        DateTime::parse_from_rfc3339("2024-01-15T10:30:00Z")
            .unwrap()
            .with_timezone(&Utc)
    }

    fn sample_expires() -> DateTime<Utc> {
        DateTime::parse_from_rfc3339("2024-01-15T22:30:00Z")
            .unwrap()
            .with_timezone(&Utc)
    }

    #[test]
    fn create_command_serializes_with_type_tag() {
        let cmd = SessionCommand::Create {
            session_id: SessionId::from_uuid(uuid::Uuid::nil()),
            user_id: UserId::from_uuid(uuid::Uuid::nil()),
            provider: OAuthProvider::GitHub,
            created_at: sample_time(),
            expires_at: sample_expires(),
            metadata: SessionMetadata::empty(),
        };

        let json = serde_json::to_value(&cmd).unwrap();

        assert_eq!(json["type"], "Create");
        assert_eq!(json["session_id"], "00000000-0000-0000-0000-000000000000");
        assert_eq!(json["user_id"], "00000000-0000-0000-0000-000000000000");
        assert_eq!(json["provider"], "github");
        assert!(json["created_at"].is_string());
        assert!(json["expires_at"].is_string());
    }

    #[test]
    fn command_roundtrips_through_json() {
        let original = SessionCommand::Refresh {
            session_id: SessionId::new(),
            refreshed_at: sample_time(),
            new_expires_at: sample_expires(),
        };

        let json = serde_json::to_string(&original).unwrap();
        let parsed: SessionCommand = serde_json::from_str(&json).unwrap();

        assert_eq!(original, parsed);
    }

    #[test]
    fn aggregate_id_extracts_correctly() {
        let sid = SessionId::new();
        let uid = UserId::new();
        let ts = sample_time();
        let exp = sample_expires();

        let commands = vec![
            SessionCommand::Create {
                session_id: sid,
                user_id: uid,
                provider: OAuthProvider::GitHub,
                created_at: ts,
                expires_at: exp,
                metadata: SessionMetadata::empty(),
            },
            SessionCommand::Refresh {
                session_id: sid,
                refreshed_at: ts,
                new_expires_at: exp,
            },
            SessionCommand::Invalidate {
                session_id: sid,
                invalidated_at: ts,
            },
        ];

        for cmd in commands {
            assert_eq!(cmd.aggregate_id(), sid);
        }
    }

    #[test]
    fn command_type_returns_correct_names() {
        let sid = SessionId::new();
        let uid = UserId::new();
        let ts = sample_time();
        let exp = sample_expires();

        assert_eq!(
            SessionCommand::Create {
                session_id: sid,
                user_id: uid,
                provider: OAuthProvider::GitHub,
                created_at: ts,
                expires_at: exp,
                metadata: SessionMetadata::empty(),
            }
            .command_type(),
            "Create"
        );

        assert_eq!(
            SessionCommand::Refresh {
                session_id: sid,
                refreshed_at: ts,
                new_expires_at: exp,
            }
            .command_type(),
            "Refresh"
        );

        assert_eq!(
            SessionCommand::Invalidate {
                session_id: sid,
                invalidated_at: ts,
            }
            .command_type(),
            "Invalidate"
        );
    }

    #[test]
    fn identifier_trait_returns_session_id() {
        let sid = SessionId::from_uuid(uuid::Uuid::nil());
        let cmd = SessionCommand::Invalidate {
            session_id: sid,
            invalidated_at: sample_time(),
        };

        assert_eq!(cmd.identifier(), "00000000-0000-0000-0000-000000000000");
    }

    #[test]
    fn decider_type_returns_session() {
        let cmd = SessionCommand::Invalidate {
            session_id: SessionId::new(),
            invalidated_at: sample_time(),
        };

        assert_eq!(cmd.decider_type(), "Session");
    }
}
