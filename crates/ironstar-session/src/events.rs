//! Domain events for the Session aggregate.
//!
//! Events represent facts that have occurred in the domain. They are:
//!
//! - **Immutable**: Once emitted, events never change
//! - **Past tense**: Named for what happened, not what should happen
//! - **Self-describing**: Contain all data needed to reconstruct state
//!
//! # Event sourcing semantics
//!
//! Events are the source of truth. Aggregate state is derived by folding
//! events through `evolve`. This means:
//!
//! - Events must contain enough data to reconstruct state
//! - Event schemas evolve via upcasters, not mutations
//! - The event store is append-only
//!
//! # Session lifecycle events
//!
//! - `Created`: Session established after OAuth callback
//! - `Refreshed`: Session TTL extended (user activity)
//! - `Invalidated`: Session explicitly terminated (logout)
//! - `Expired`: Session TTL exceeded (boundary-generated)
//!
//! Note: `Expired` events are generated by the boundary layer when a
//! scheduled check detects that a session has exceeded its `expires_at`.
//! The decider does not generate this event directly.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use ts_rs::TS;

use crate::values::{OAuthProvider, SessionId, SessionMetadata, UserId};
use ironstar_core::{DeciderType, EventType, Identifier, IsFinal};

/// Events emitted by the Session aggregate.
///
/// Each variant represents a state change that occurred. The aggregate's
/// current state is the result of applying all its events in order.
///
/// # Versioning
///
/// Events have an implicit version (currently v1). Schema evolution is
/// handled by upcasters that transform old event formats during loading.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, TS)]
#[serde(tag = "type")]
#[ts(export, export_to = "events/")]
pub enum SessionEvent {
    /// A new session was created after successful OAuth authentication.
    Created {
        /// Unique session identifier.
        session_id: SessionId,
        /// Canonical user identifier.
        user_id: UserId,
        /// OAuth provider that authenticated this session.
        provider: OAuthProvider,
        /// When the session was created.
        created_at: DateTime<Utc>,
        /// When the session expires.
        expires_at: DateTime<Utc>,
        /// Audit trail metadata (IP, user agent).
        metadata: SessionMetadata,
    },

    /// The session was refreshed (TTL extended).
    Refreshed {
        /// Which session was refreshed.
        session_id: SessionId,
        /// When the refresh occurred.
        refreshed_at: DateTime<Utc>,
        /// New expiration timestamp.
        new_expires_at: DateTime<Utc>,
    },

    /// The session was explicitly invalidated (logout).
    Invalidated {
        /// Which session was invalidated.
        session_id: SessionId,
        /// When invalidation occurred.
        invalidated_at: DateTime<Utc>,
    },

    /// The session expired (boundary-generated event).
    ///
    /// This event is not emitted by the decider; it is generated by the
    /// boundary layer when a scheduled expiration check fires.
    Expired {
        /// Which session expired.
        session_id: SessionId,
        /// When expiration was detected.
        expired_at: DateTime<Utc>,
    },
}

impl SessionEvent {
    /// Extract the aggregate ID this event belongs to.
    ///
    /// Used by the event store to route events to the correct aggregate.
    #[must_use]
    pub fn aggregate_id(&self) -> SessionId {
        match self {
            Self::Created { session_id, .. }
            | Self::Refreshed { session_id, .. }
            | Self::Invalidated { session_id, .. }
            | Self::Expired { session_id, .. } => *session_id,
        }
    }

    /// Get the event type name for storage and routing.
    ///
    /// This matches the serde tag value and is used for:
    /// - Event store `event_type` column
    /// - Upcaster matching
    /// - Metrics and logging
    #[must_use]
    pub fn event_type_name(&self) -> &'static str {
        match self {
            Self::Created { .. } => "Created",
            Self::Refreshed { .. } => "Refreshed",
            Self::Invalidated { .. } => "Invalidated",
            Self::Expired { .. } => "Expired",
        }
    }

    /// Get the event version for schema evolution.
    ///
    /// All current events are version 1. When schemas evolve, bump this
    /// version and add an upcaster to transform old events.
    #[must_use]
    pub fn event_version(&self) -> &'static str {
        "1"
    }
}

impl Identifier for SessionEvent {
    fn identifier(&self) -> String {
        self.aggregate_id().to_string()
    }
}

impl EventType for SessionEvent {
    fn event_type(&self) -> String {
        self.event_type_name().to_string()
    }
}

impl DeciderType for SessionEvent {
    fn decider_type(&self) -> String {
        "Session".to_string()
    }
}

impl IsFinal for SessionEvent {
    fn is_final(&self) -> bool {
        matches!(self, Self::Invalidated { .. } | Self::Expired { .. })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn sample_session_id() -> SessionId {
        SessionId::from_uuid(uuid::Uuid::nil())
    }

    fn sample_user_id() -> UserId {
        UserId::from_uuid(uuid::Uuid::nil())
    }

    fn sample_time() -> DateTime<Utc> {
        DateTime::parse_from_rfc3339("2024-01-15T10:30:00Z")
            .unwrap()
            .with_timezone(&Utc)
    }

    fn sample_expires() -> DateTime<Utc> {
        DateTime::parse_from_rfc3339("2024-01-15T22:30:00Z")
            .unwrap()
            .with_timezone(&Utc)
    }

    #[test]
    fn created_event_serializes_with_type_tag() {
        let event = SessionEvent::Created {
            session_id: sample_session_id(),
            user_id: sample_user_id(),
            provider: OAuthProvider::GitHub,
            created_at: sample_time(),
            expires_at: sample_expires(),
            metadata: SessionMetadata::empty(),
        };

        let json = serde_json::to_value(&event).unwrap();

        assert_eq!(json["type"], "Created");
        assert_eq!(json["session_id"], "00000000-0000-0000-0000-000000000000");
        assert_eq!(json["user_id"], "00000000-0000-0000-0000-000000000000");
        assert_eq!(json["provider"], "github");
        assert!(json["created_at"].is_string());
        assert!(json["expires_at"].is_string());
    }

    #[test]
    fn event_roundtrips_through_json() {
        let original = SessionEvent::Refreshed {
            session_id: sample_session_id(),
            refreshed_at: sample_time(),
            new_expires_at: sample_expires(),
        };

        let json = serde_json::to_string(&original).unwrap();
        let parsed: SessionEvent = serde_json::from_str(&json).unwrap();

        assert_eq!(original, parsed);
    }

    #[test]
    fn aggregate_id_extracts_correctly() {
        let sid = SessionId::new();
        let event = SessionEvent::Invalidated {
            session_id: sid,
            invalidated_at: sample_time(),
        };

        assert_eq!(event.aggregate_id(), sid);
    }

    #[test]
    fn event_type_matches_serde_tag() {
        let events = vec![
            (
                SessionEvent::Created {
                    session_id: sample_session_id(),
                    user_id: sample_user_id(),
                    provider: OAuthProvider::GitHub,
                    created_at: sample_time(),
                    expires_at: sample_expires(),
                    metadata: SessionMetadata::empty(),
                },
                "Created",
            ),
            (
                SessionEvent::Refreshed {
                    session_id: sample_session_id(),
                    refreshed_at: sample_time(),
                    new_expires_at: sample_expires(),
                },
                "Refreshed",
            ),
            (
                SessionEvent::Invalidated {
                    session_id: sample_session_id(),
                    invalidated_at: sample_time(),
                },
                "Invalidated",
            ),
            (
                SessionEvent::Expired {
                    session_id: sample_session_id(),
                    expired_at: sample_time(),
                },
                "Expired",
            ),
        ];

        for (event, expected_type) in events {
            assert_eq!(event.event_type_name(), expected_type);

            // Verify serde tag matches
            let json = serde_json::to_value(&event).unwrap();
            assert_eq!(json["type"], expected_type);
        }
    }

    #[test]
    fn is_final_for_terminal_states() {
        let non_final = vec![
            SessionEvent::Created {
                session_id: sample_session_id(),
                user_id: sample_user_id(),
                provider: OAuthProvider::GitHub,
                created_at: sample_time(),
                expires_at: sample_expires(),
                metadata: SessionMetadata::empty(),
            },
            SessionEvent::Refreshed {
                session_id: sample_session_id(),
                refreshed_at: sample_time(),
                new_expires_at: sample_expires(),
            },
        ];

        let final_events = vec![
            SessionEvent::Invalidated {
                session_id: sample_session_id(),
                invalidated_at: sample_time(),
            },
            SessionEvent::Expired {
                session_id: sample_session_id(),
                expired_at: sample_time(),
            },
        ];

        for event in non_final {
            assert!(!event.is_final(), "{:?} should not be final", event);
        }

        for event in final_events {
            assert!(event.is_final(), "{:?} should be final", event);
        }
    }

    #[test]
    fn decider_type_returns_session() {
        let event = SessionEvent::Expired {
            session_id: sample_session_id(),
            expired_at: sample_time(),
        };

        assert_eq!(event.decider_type(), "Session");
    }
}
