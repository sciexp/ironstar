||| Todo bounded context - Generic Example domain
|||
||| Todo validates that ironstar's CQRS/ES infrastructure works for ANY domain
||| without coupling to Analytics-specific concepts. Maximally simple.
|||
||| Domain classification: Generic domain
||| - Todo serves as the canonical example aggregate for the template
||| - Demonstrates full Decider/View/Saga patterns with state machine
|||
||| Key abstractions:
||| - TodoCommand: Create, Complete, Uncomplete, Delete
||| - TodoEvent: Created, Completed, Uncompleted, Deleted
||| - TodoState: NonExistent, Active, CompletedTodo, DeletedTodo (state machine)
||| - TodoDecider: full command handling with validation
||| - TodoListView: projection for list view (denormalized)
||| - completionNotificationSaga: example process manager
|||
||| This module demonstrates:
||| 1. State machine encoding as sum types
||| 2. Command validation with Either err (List e)
||| 3. Totality of evolve (events cannot fail)
||| 4. Idempotent operations returning empty event list
||| 5. Terminal state (Deleted) preventing further changes
module Todo.Todo

import Core.Decider
import Core.View
import Core.Saga
import Core.Event
import Data.List

%default total

------------------------------------------------------------------------
-- Value Objects
------------------------------------------------------------------------

||| Todo aggregate identifier
public export
record TodoId where
  constructor MkTodoId
  unTodoId : String

public export
Eq TodoId where
  (MkTodoId x) == (MkTodoId y) = x == y

------------------------------------------------------------------------
-- Commands
------------------------------------------------------------------------

||| Commands that can be issued against a Todo aggregate
public export
data TodoCommand
  = Create String        -- Create with text content
  | Complete             -- Mark as complete
  | Uncomplete           -- Mark as incomplete
  | Delete               -- Delete the todo

------------------------------------------------------------------------
-- Events
------------------------------------------------------------------------

||| Domain events generated by Todo aggregate
|||
||| Invariant: All events are past-tense facts (Hoffman's Law 1)
||| Invariant: Event payload is immutable once recorded
public export
data TodoEvent
  = Created TodoId String Timestamp    -- (id, text, timestamp)
  | Completed Timestamp                -- (timestamp)
  | Uncompleted Timestamp              -- (timestamp)
  | Deleted Timestamp                  -- (timestamp)

------------------------------------------------------------------------
-- State Machine
------------------------------------------------------------------------

||| Todo state machine: NonExistent → Active ↔ Completed → Deleted
|||
||| The state machine encodes all valid states and prevents invalid
||| transitions at the type level via pattern matching in decide.
public export
data TodoState
  = NonExistent              -- No aggregate exists (initial state)
  | Active TodoId String     -- (id, text) - aggregate exists, not completed
  | CompletedTodo TodoId String  -- (id, text) - aggregate exists, completed
  | DeletedTodo TodoId       -- (id) - terminal state, no further changes allowed

------------------------------------------------------------------------
-- Error type
------------------------------------------------------------------------

||| Error type for command validation failures
public export
data TodoError
  = TodoAlreadyExists
  | CannotCompleteInCurrentState
  | CannotUncompleteInCurrentState
  | CannotDeleteNothing

public export
Show TodoError where
  show TodoAlreadyExists = "Todo already exists"
  show CannotCompleteInCurrentState = "Cannot complete in current state"
  show CannotUncompleteInCurrentState = "Cannot uncomplete in current state"
  show CannotDeleteNothing = "Nothing to delete"

------------------------------------------------------------------------
-- Decider: Pure decision logic
------------------------------------------------------------------------

||| The Decider encapsulates all command validation and event emission logic.
|||
||| Key property: decide is pure - same command + state → same events
||| Key property: evolve is total - events cannot fail to be applied
||| Key property: idempotent operations return empty event list (not errors)
public export
todoDecider : Decider TodoCommand TodoState TodoEvent TodoError
todoDecider = MkDecider
  { decide = \cmd, state => case (cmd, state) of
      -- Create only from NonExistent (cannot overwrite)
      (Create text, NonExistent) =>
        -- In a real implementation, the TodoId would be generated here
        -- or passed in via command. For this stub, we use a placeholder.
        let newId = MkTodoId "todo-1"
            now = MkTimestamp 0  -- Placeholder: would come from system
        in Right [Created newId text now]

      (Create _, _) =>
        Left TodoAlreadyExists

      -- Complete: transition Active → Completed
      -- Idempotent: already completed returns empty list
      (Complete, Active _ _) =>
        let now = MkTimestamp 0
        in Right [Completed now]

      (Complete, CompletedTodo _ _) =>
        -- Idempotent: already completed, no change needed
        Right []

      (Complete, _) =>
        Left CannotCompleteInCurrentState

      -- Uncomplete: transition Completed → Active
      -- Idempotent: already active returns empty list
      (Uncomplete, CompletedTodo _ _) =>
        let now = MkTimestamp 0
        in Right [Uncompleted now]

      (Uncomplete, Active _ _) =>
        -- Idempotent: already active, no change needed
        Right []

      (Uncomplete, _) =>
        Left CannotUncompleteInCurrentState

      -- Delete: terminal state from Active or Completed
      -- Idempotent: already deleted returns empty list
      (Delete, Active _ _) =>
        let now = MkTimestamp 0
        in Right [Deleted now]

      (Delete, CompletedTodo _ _) =>
        let now = MkTimestamp 0
        in Right [Deleted now]

      (Delete, DeletedTodo _) =>
        -- Idempotent: already deleted, no change needed
        Right []

      (Delete, NonExistent) =>
        Left CannotDeleteNothing

  , evolve = \state, event => case event of
      -- Create transitions NonExistent → Active
      Created tid text _ =>
        Active tid text

      -- Completed transitions Active → Completed
      -- On other states: no-op (state preservation)
      Completed _ => case state of
        Active tid text => CompletedTodo tid text
        other => other

      -- Uncompleted transitions Completed → Active
      -- On other states: no-op (state preservation)
      Uncompleted _ => case state of
        CompletedTodo tid text => Active tid text
        other => other

      -- Deleted is terminal: Active/Completed → Deleted
      -- On other states: no-op (state preservation)
      Deleted _ => case state of
        Active tid _ => DeletedTodo tid
        CompletedTodo tid _ => DeletedTodo tid
        other => other

  , initialState = NonExistent
  }

------------------------------------------------------------------------
-- View: Todo List Projection
------------------------------------------------------------------------

||| Todo list view: denormalized read model for displaying all todos
|||
||| This is a simple projection that maintains a list of (id, text, completed).
||| In a real system, this would be persisted in a separate table and updated
||| whenever events arrive.
public export
record TodoListView where
  constructor MkTodoListView
  items : List (TodoId, String, Bool)  -- (id, text, is_completed)

||| The TodoListView projection evolves by applying events
|||
||| Note: This simple projection has a limitation: the Completed/Uncompleted
||| events don't carry the TodoId, so we can't update the completion status
||| in the list. A real view would either:
||| 1. Include TodoId in all events (recommended), or
||| 2. Maintain per-aggregate state and dispatch events by aggregate ID
public export
todoListView : View TodoListView TodoEvent
todoListView = MkView
  { evolve = \state, event => case event of
      Created tid text _ =>
        -- Add new item to the list
        { items := (tid, text, False) :: state.items } state

      Completed _ =>
        -- Would need TodoId in event to update completion status
        -- For now, leave list unchanged
        state

      Uncompleted _ =>
        -- Would need TodoId in event to update completion status
        state

      Deleted _ =>
        -- Would need TodoId in event to remove from list
        state

  , initialState = MkTodoListView []
  }

------------------------------------------------------------------------
-- Saga: Completion Notification (Example Process Manager)
------------------------------------------------------------------------

||| Command types that other aggregates can handle
||| Example: NotificationAggregate or EmailAggregate
public export
data NotificationCommand
  = SendCompletionNotification TodoId
  | SendCompletionReminder TodoId

||| Saga that reacts to Todo events and produces notification commands
|||
||| Use case: When a Todo is completed, automatically send a notification
||| to the user acknowledging completion.
|||
||| In a real system, this saga would:
||| 1. Listen for Completed events
||| 2. Extract TodoId from context (e.g., aggregate ID)
||| 3. Emit SendCompletionNotification command
|||
||| Note: The current Completed event doesn't carry TodoId, so this saga
||| can only produce empty command lists. A real implementation would
||| include TodoId in all events.
public export
completionNotificationSaga : Saga TodoEvent NotificationCommand
completionNotificationSaga = MkSaga
  { react = \event => case event of
      Completed _ =>
        -- Would need TodoId in event to create notification command
        -- This would be: [SendCompletionNotification todoId]
        []

      _ => []
  }

||| Alternative saga that uses Saga composition to add reminders
|||
||| Demonstrates saga merging: multiple process managers reacting to same events
||| In a real system, you might merge notification + analytics sagas:
||| ```
||| let combined = completionNotificationSaga <|> analyticsEventSaga
||| ```
public export
todoNotificationSaga : Saga TodoEvent NotificationCommand
todoNotificationSaga = completionNotificationSaga

------------------------------------------------------------------------
-- Laws and Proofs
------------------------------------------------------------------------

||| Proof: State reconstruction via event replay is deterministic
|||
||| For any event history, replaying produces the same final state.
||| This follows from fold associativity (foldl is deterministic).
|||
||| Formal: reconstruct todoDecider es1 = reconstruct todoDecider es1
public export
0 todoReplayDeterminism : (es : List TodoEvent) ->
    reconstruct todoDecider es = reconstruct todoDecider es
todoReplayDeterminism es = Refl

||| Proof: Decider satisfies referential transparency
|||
||| The decide function is pure: same command and state always produce
||| the same event list. This is enforced by Idris 2's total function
||| requirement (no IO, no global state).
public export
0 todoDecidePurity : (cmd : TodoCommand) -> (st : TodoState) ->
    todoDecider.decide cmd st = todoDecider.decide cmd st
todoDecidePurity cmd st = Refl

||| Proof: Commands are deterministic
|||
||| The decide function is pure (referential transparent):
||| the same command applied to the same state always produces the same events.
|||
||| This is enforced by Idris 2's %default total requirement:
||| no IO, no global state, no side effects.
|||
||| Pattern: All decisions are computed from the command and state alone.
public export
0 todoDecisionsAreDeterministic : (cmd : TodoCommand) -> (st : TodoState) ->
    (todoDecider.decide cmd st = todoDecider.decide cmd st)
todoDecisionsAreDeterministic cmd st = Refl
