---
id: Session
name: Session
version: 0.0.1
summary: |
  Aggregate root managing authenticated user sessions with TTL-based lifecycle.
owners:
  - engineering
aggregateRoot: true
identifier: id
properties:
  - name: id
    type: string
    required: true
    format: uuid
    summary: Unique session identifier
  - name: userId
    type: reference
    required: true
    referenceTo: User
    summary: Reference to the authenticated user
  - name: status
    type: string
    required: true
    enum: [Active, Expired, Invalidated]
    summary: Current session lifecycle state
  - name: expiresAt
    type: string
    required: true
    format: date-time
    summary: Timestamp when session will automatically expire
  - name: createdAt
    type: string
    required: true
    format: date-time
    summary: Timestamp when session was created
---

## Overview

The Session aggregate is the core entity in the Session bounded context, managing authenticated user sessions from creation through expiration or invalidation.
Sessions are created after successful OAuth callback processing and maintain a TTL-based lifecycle.

## Decider Pattern

The Session aggregate follows the fmodel-rust Decider pattern with pure synchronous decision logic.

**Commands handled:**
- `CreateSession`: Initiates a new session after OAuth callback
- `RefreshSession`: Extends session TTL for continued activity
- `InvalidateSession`: Explicit logout terminates session
- `ExpireSession`: System-triggered TTL expiration

**State transitions:**

```
NoSession -> Active(id, userId, expiresAt)
Active    -> Active (refresh extends TTL)
Active    -> Expired (TTL elapsed)
Active    -> Invalidated (explicit logout)
```

## Relationships

- **User**: Each Session references exactly one User (many-to-one relationship)
- **SessionService**: Session is the aggregate root managed by SessionService

## Invariants

- A session cannot be refreshed after expiration or invalidation
- Session TTL must be positive and within configured bounds
- Only one active session per user (enforced at application layer)

## fmodel-rust Implementation

This aggregate implements the Decider pattern from fmodel-rust.

### decide

```rust
fn decide(cmd: SessionCommand, state: &SessionState) -> Result<Vec<SessionEvent>, SessionError>
```

**Command handling logic:**

- **CreateSession(UserId, OAuthProvider)** when `NoSession`:
  - Validates: No preconditions
  - Produces: `SessionCreated(SessionId, UserId, OAuthProvider, Timestamp, ExpiresAt)`
  - Boundary layer fills: SessionId, Timestamp, ExpiresAt

- **CreateSession(_, _)** when `Active(_)`, `Expired(_)`, or `Invalidated(_)`:
  - Validates: Fails with error "Session already exists"

- **RefreshSession(SessionId)** when `Active(currentId, _, _)`:
  - Validates: Checks if SessionId matches
  - Produces: `SessionRefreshed(SessionId, ExpiresAt, Timestamp)`

- **RefreshSession(_)** when `NoSession`, `Expired(_)`, or `Invalidated(_)`:
  - Validates: Fails with error "Cannot refresh non-active session"

- **InvalidateSession(SessionId)** when `Active(currentId, _, _)`:
  - Validates: Checks if SessionId matches
  - Produces: `SessionInvalidated(SessionId, Timestamp)`

- **InvalidateSession(_)** when `NoSession`, `Expired(_)`, or `Invalidated(_)`:
  - Validates: Fails with error "No active session to invalidate"

**Note:** `SessionExpired` events are generated by the boundary layer when TTL elapses, not by the decide function.

### evolve

```rust
fn evolve(state: SessionState, event: &SessionEvent) -> SessionState
```

**Event application logic:**

- **SessionCreated(SessionId, UserId, _, _, ExpiresAt)**:
  - Updates state: `NoSession` → `Active(SessionId, UserId, ExpiresAt)`

- **SessionRefreshed(SessionId, ExpiresAt, _)**:
  - Updates state: `Active(_, UserId, _)` → `Active(SessionId, UserId, ExpiresAt)`
  - Preserves UserId, updates expiration

- **SessionInvalidated(SessionId, _)**:
  - Updates state: `Active(_, _, _)` → `Invalidated(SessionId)`

- **SessionExpired(SessionId, _)**:
  - Updates state: `Active(_, _, _)` → `Expired(SessionId)`

### initial_state

```rust
fn initial_state() -> SessionState
```

Returns `NoSession`, representing the initial state before authentication.
