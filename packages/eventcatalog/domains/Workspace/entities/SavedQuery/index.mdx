---
id: SavedQuery
name: Saved Query
version: 0.0.1
summary: |
  Aggregate root representing a named, reusable SQL query with dataset reference.
owners:
  - engineering
aggregateRoot: true
identifier: id
properties:
  - name: id
    type: string
    required: true
    format: uuid
    summary: Unique saved query identifier
  - name: workspaceId
    type: reference
    required: true
    referenceTo: Workspace
    summary: Reference to the Workspace this saved query belongs to
  - name: name
    type: string
    required: true
    summary: Human-readable query name for display
  - name: ownerId
    type: reference
    required: true
    referenceTo: User
    summary: Reference to the user who owns this query
  - name: sqlStatement
    type: string
    required: true
    summary: The SQL query text
  - name: datasetReference
    type: string
    required: true
    format: uri
    summary: URI reference to the target dataset (e.g., ducklake://catalog/dataset)
---

## Overview

The SavedQuery aggregate persists named SQL queries for reuse across sessions.
Saved queries provide a library of pre-built analyses that can be referenced by Dashboard charts or executed interactively.

## Decider Pattern

The SavedQuery aggregate follows the fmodel-rust Decider pattern.

**Commands handled:**
- `SaveQuery`: Creates a new saved query
- `RenameSavedQuery`: Updates the query name
- `UpdateSavedQuerySql`: Modifies the SQL statement
- `UpdateDatasetReference`: Changes the target dataset
- `DeleteSavedQuery`: Removes the saved query

**Events emitted:**
- `SavedQueryCreated`: New query saved
- `SavedQueryRenamed`: Name updated
- `SavedQuerySqlUpdated`: SQL statement modified
- `SavedQueryDatasetRefUpdated`: Dataset reference changed
- `SavedQueryDeleted`: Query removed

## Relationships

- **Workspace**: SavedQuery belongs to exactly one Workspace (many-to-one)
- **User** (Session): Each saved query has a single owner (many-to-one)
- **Dataset** (Analytics): References target dataset via URI
- **Dashboard**: Charts reference SavedQuery as data source
- **SavedQueryService**: SavedQuery is managed by SavedQueryService

## Dataset Reference URI Format

The `datasetReference` field uses a URI scheme for flexible dataset addressing:

| Scheme | Example | Description |
|--------|---------|-------------|
| `ducklake://` | `ducklake://catalog/schema/table` | DuckLake catalog reference |
| `hf://` | `hf://datasets/org/dataset` | HuggingFace dataset |
| `s3://` | `s3://bucket/path` | S3-compatible storage |

## Invariants

- SavedQuery must belong to exactly one Workspace
- Query name must be unique per owner within a Workspace
- SQL statement must be syntactically valid (validated at save time)
- Only the owner can modify or delete the saved query

## fmodel-rust Implementation

This aggregate implements the Decider pattern from fmodel-rust.

### decide

```rust
fn decide(cmd: SavedQueryCommand, state: &SavedQueryState) -> Result<Vec<SavedQueryEvent>, String>
```

**Command handling logic:**

- **SaveQuery(name, sql, dataset_ref)** when `NoQuery`:
  - Validates: `name` and `sql` must be non-empty
  - Produces: `QuerySaved(query_id, name, sql, dataset_ref, timestamp)`
  - Error if name empty: "Query name cannot be empty"
  - Error if SQL empty: "Query SQL cannot be empty"
  - Error if query exists: "Query already exists"

- **DeleteQuery** when `QueryExists(_)`:
  - Validates: Query must exist
  - Produces: `QueryDeleted(timestamp)`
  - Error if no query: "No query to delete"

- **RenameQuery(new_name)** when `QueryExists(_)`:
  - Validates: `new_name` must be non-empty
  - Produces: `QueryRenamed(new_name, timestamp)`
  - Error if name empty: "Query name cannot be empty"

- **UpdateQuerySql(new_sql)** when `QueryExists(_)`:
  - Validates: `new_sql` must be non-empty
  - Produces: `QuerySqlUpdated(new_sql, timestamp)`
  - Error if SQL empty: "Query SQL cannot be empty"

- **UpdateDatasetRef(new_ref)** when `QueryExists(_)`:
  - Validates: Query must exist
  - Produces: `DatasetRefUpdated(new_ref, timestamp)`

### evolve

```rust
fn evolve(state: SavedQueryState, event: &SavedQueryEvent) -> SavedQueryState
```

**Event application logic:**

- **QuerySaved(query_id, name, sql, dataset_ref, _)**:
  - Updates: `NoQuery` → `QueryExists(query_id, name, sql, dataset_ref)`

- **QueryDeleted(_)**:
  - Updates: `QueryExists(_)` → `NoQuery`

- **QueryRenamed(new_name, _)**:
  - Updates: `name` field in `QueryExists`, preserving other fields

- **QuerySqlUpdated(new_sql, _)**:
  - Updates: `sql` field in `QueryExists`, preserving other fields

- **DatasetRefUpdated(new_ref, _)**:
  - Updates: `dataset_ref` field in `QueryExists`, preserving other fields

### initial_state

```rust
fn initial_state() -> SavedQueryState
```

Returns `SavedQueryState::NoQuery`.

**Note:** Each SavedQuery is a separate aggregate. Multiple queries per user use separate aggregates with IDs like `user_id/query_name`.
