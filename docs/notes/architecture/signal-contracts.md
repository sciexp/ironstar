# Type-safe signal contracts with ts-rs

Ironstar uses ts-rs to generate TypeScript type definitions from Rust signal structs, ensuring type safety across the full Datastar request/response cycle.

## The contract problem

Datastar signals flow through multiple boundaries:

```
HTML template (data-signals="{...}")
    ↓ JSON string
Browser (Datastar signals)
    ↓ JSON body/query param
Rust handler (ReadSignals<T>)
    ↓ serde deserialization
Rust struct
```

Without type synchronization, mismatches can occur:
- Frontend sends `filter: "all"`, backend expects `filter: "All"` (case mismatch)
- Frontend sends `count: "5"`, backend expects `count: 5` (type mismatch)
- Frontend sends extra fields backend doesn't expect (silent failures)

ts-rs solves this by generating TypeScript types from the authoritative Rust definitions.

---

## Basic usage

### Defining signal types in Rust

```rust
// src/domain/signals.rs
use ts_rs::TS;
use serde::{Serialize, Deserialize};
use uuid::Uuid;

/// Todo application signals
#[derive(Clone, Serialize, Deserialize, TS)]
#[ts(export, export_to = "web-components/types/")]
pub struct TodoSignals {
    /// Current input field value
    #[ts(optional)]
    pub input: Option<String>,

    /// Active filter mode
    pub filter: TodoFilter,

    /// ID of todo being edited (if any)
    #[ts(optional)]
    pub editing_id: Option<Uuid>,

    /// Loading indicator state
    #[serde(default)]
    pub loading: bool,
}

/// Filter options for todo list
#[derive(Clone, Copy, Serialize, Deserialize, TS)]
pub enum TodoFilter {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "active")]
    Active,
    #[serde(rename = "completed")]
    Completed,
}

impl Default for TodoFilter {
    fn default() -> Self {
        Self::All
    }
}
```

### Generating TypeScript types

ts-rs generates types during test execution:

```bash
# Generate all exported types
cargo test --lib

# Or with explicit environment variable
TS_RS_EXPORT_DIR=web-components/types cargo test --lib
```

This produces `web-components/types/TodoSignals.ts`:

```typescript
// This file is auto-generated by ts-rs. Do not edit.
export type TodoSignals = {
  input?: string;
  filter: TodoFilter;
  editing_id?: string;
  loading: boolean;
};

export type TodoFilter = "all" | "active" | "completed";
```

---

## Type mappings

ts-rs converts Rust types to TypeScript according to these rules:

| Rust Type | TypeScript Type | Notes |
|-----------|-----------------|-------|
| `String` | `string` | |
| `i32`, `i64`, `u32`, `u64` | `number` | |
| `i128`, `u128` | `bigint` | Configurable via `TS_RS_LARGE_INT` |
| `bool` | `boolean` | |
| `Option<T>` | `T \| null` | Or `T?` with `#[ts(optional)]` |
| `Vec<T>` | `Array<T>` | |
| `HashMap<K, V>` | `Record<K, V>` | |
| `Uuid` | `string` | Requires `uuid-impl` feature |
| Unit variants | String literal union | `"All" \| "Active"` |
| Struct variants | Discriminated union | With `#[serde(tag = "type")]` |

### Option handling

By default, `Option<T>` becomes `T | null`. Use `#[ts(optional)]` for optional fields:

```rust
#[derive(TS)]
struct Signals {
    // Required field: must be present, can be null
    name: Option<String>,  // -> name: string | null

    // Optional field: can be omitted entirely
    #[ts(optional)]
    nickname: Option<String>,  // -> nickname?: string
}
```

For struct-wide optional fields:

```rust
#[derive(TS)]
#[ts(optional_fields)]
struct Signals {
    name: Option<String>,     // -> name?: string
    nickname: Option<String>, // -> nickname?: string
}
```

### Enum serialization

ts-rs respects serde's enum representations:

```rust
// External tagging (default): {"Active": null} or {"WithData": {...}}
#[derive(Serialize, TS)]
enum Status {
    Active,
    WithData { count: i32 },
}

// Internal tagging: {"type": "Active"} or {"type": "WithData", "count": 5}
#[derive(Serialize, TS)]
#[serde(tag = "type")]
enum Action {
    Add { text: String },
    Delete { id: String },
}

// Untagged: just the variant value
#[derive(Serialize, TS)]
#[serde(untagged)]
enum StringOrNumber {
    String(String),
    Number(i32),
}
```

---

## Project structure

Recommended layout for ironstar:

```
ironstar/
├── .cargo/
│   └── config.toml              # TS_RS_EXPORT_DIR setting
├── Cargo.toml
├── src/
│   └── domain/
│       ├── mod.rs
│       └── signals.rs           # Signal type definitions
├── web-components/
│   ├── types/                   # Generated TypeScript (git-ignored)
│   │   ├── TodoSignals.ts
│   │   └── TodoFilter.ts
│   ├── tsconfig.json            # Include types/ in compilation
│   └── index.ts
└── justfile                     # Build tasks
```

### Cargo configuration

```toml
# .cargo/config.toml
[env]
TS_RS_EXPORT_DIR = { value = "web-components/types", relative = true }
```

### Cargo.toml dependencies

```toml
[dependencies]
ts-rs = { version = "11.1", features = ["serde-compat", "uuid-impl"] }
serde = { version = "1", features = ["derive"] }
uuid = { version = "1", features = ["v4", "serde"] }

[dev-dependencies]
# None needed for ts-rs
```

### TypeScript configuration

```json
// web-components/tsconfig.json
{
  "compilerOptions": {
    "strict": true,
    "module": "ESNext",
    "target": "ESNext",
    "moduleResolution": "bundler",
    "paths": {
      "@types/*": ["./types/*"]
    }
  },
  "include": ["**/*.ts", "types/**/*.ts"]
}
```

### Build integration

```justfile
# justfile

# Generate TypeScript types from Rust signal definitions
gen-types:
    TS_RS_EXPORT_DIR=web-components/types cargo test --lib 2>&1 | grep -E "^test|export_bindings"
    @echo "Generated types in web-components/types/"

# Run all builds
build: gen-types
    cd web-components && pnpm build
    cargo build --release

# Development with type generation
dev:
    @just gen-types
    # Start watchers...
```

---

## Usage in Datastar templates

### Server-rendered initial state

```rust
use hypertext::prelude::*;
use crate::domain::signals::{TodoSignals, TodoFilter};

fn todo_page(signals: &TodoSignals) -> impl Renderable {
    maud! {
        div
            #main
            "data-signals"=(serde_json::to_string(signals).unwrap())
            "data-init"="@get('/todos/updates')"
        {
            // Page content
        }
    }
}

// Handler
async fn page() -> impl IntoResponse {
    let signals = TodoSignals {
        input: None,
        filter: TodoFilter::All,
        editing_id: None,
        loading: false,
    };
    todo_page(&signals).render()
}
```

### Frontend type safety

```typescript
// web-components/components/todo-form.ts
import type { TodoSignals, TodoFilter } from '@types/TodoSignals';

// TypeScript enforces correct signal structure
const validateSignals = (signals: TodoSignals): boolean => {
  // Type-safe access to signal properties
  const validFilters: TodoFilter[] = ['all', 'active', 'completed'];
  return validFilters.includes(signals.filter);
};
```

### Type-safe API calls

```typescript
// The TodoSignals type ensures correct JSON structure
const signals: TodoSignals = {
  input: 'New todo',
  filter: 'all',
  loading: true,
};

// Datastar sends this as the request body
// ReadSignals<TodoSignals> on the Rust side will parse it correctly
```

---

## Best practices

### Use serde rename consistently

serde attributes affect both JSON serialization and TypeScript output:

```rust
#[derive(Serialize, Deserialize, TS)]
#[serde(rename_all = "camelCase")]
struct UserSignals {
    first_name: String,  // -> firstName in both JSON and TS
    last_name: String,   // -> lastName in both JSON and TS
}
```

### Define signals in domain layer

Keep signal types with your domain model, not scattered across handlers:

```rust
// src/domain/signals.rs - centralized signal definitions
pub mod todo;
pub mod user;
pub mod settings;

// Re-export for convenience
pub use todo::*;
pub use user::*;
```

### Generate types in CI

Add type generation to your CI pipeline to catch mismatches:

```yaml
# .github/workflows/ci.yml
- name: Generate TypeScript types
  run: cargo test --lib
- name: Check TypeScript compiles
  run: cd web-components && pnpm tsc --noEmit
```

### Version control strategy

Option A: Commit generated types (simpler for frontend developers)

```gitignore
# Don't ignore types
# web-components/types/
```

Option B: Generate on build (ensures freshness)

```gitignore
# Ignore generated types
web-components/types/
```

Ironstar recommends Option A for development experience, with CI verification.

---

## Limitations and workarounds

### No build.rs integration

ts-rs generates types via `cargo test`, not `cargo build`. This is intentional: type generation is a development-time concern, not a runtime concern.

Workaround: Run `just gen-types` before `pnpm build` in your development workflow.

### Generic types require concrete specifications

```rust
// Won't work: generic T is not exported
#[derive(TS)]
struct Response<T> { data: T }

// Works: concrete type specification
#[derive(TS)]
#[ts(concrete(T = String))]
struct Response<T> { data: T }
```

### Recursive types need explicit handling

```rust
// May cause issues with deeply recursive types
#[derive(TS)]
struct TreeNode {
    value: String,
    children: Vec<TreeNode>,  // Recursive
}

// Workaround: use #[ts(type = "...")] for custom handling
```

---

## Related documentation

- datastar-rust ReadSignals: `~/projects/rust-workspace/datastar-rust/src/axum.rs`
- ts-rs documentation: `~/projects/rust-workspace/ts-rs/`
- Signal extraction patterns: `docs/notes/architecture/stack-component-selection.md` (datastar-rust section)
